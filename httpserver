#!/usr/bin/env python3

import requests
import zipfile
import os
import socket 
import csv
import time
import gzip
import threading

CACHED_FILES_LIST = "cached_files.txt"
PORT = 8080
PAGEVIEWS_FILENAME = "pageviews.csv"
ORIGIN = "cs5700cdnorigin.ccs.neu.edu"
MAX_CACHE_SIZE_BYTES = 1000000 * 15
MAX_CACHED_FILES = 1000

"""
Handles the client request. Either gets the html from source or cache
and returns the html to the client.

Runs with ./httpserver -p <port> -o <origin>
"""
class HttpServer:
    def __init__(self, port, origin) -> None:
        self.port = port
        self.origin = origin

        self.current_folder = os.path.abspath(os.getcwd())
        self.cached_folder = self.current_folder + '/cached_files'
        
        self.current_size = os.path.getsize(self.current_folder)
        print('current folder size', self.current_size)
        
        with open(CACHED_FILES_LIST, 'r') as cf:
            all_files = cf.read()
            self.cached_files = all_files.split('\n')[:-1]
        
        self.create_and_connect_socket()

    def create_and_connect_socket(self):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        #self._ip = socket.gethostname()
        #print('origin ip: ', self._ip)

        try:
            self.sock.connect((socket.gethostname(), self.port))
            #self.sock.listen(10)
            print("Http Server Connected.")
        except Exception as e:
            print("HTTP could not connect: ", e)
            self.sock.close()

        print("Socket created. Ready to receive client requests.")

    def get_html(self, client_request_page):
        
        page_name = client_request_page + '.zip'
        if page_name in self.cached_files:
            return self.get_file(page_name)
        else:
            #self.cache.add_request_to_cache(client_request)
            response = requests.get((page_name, 8080))
            if response.status_code == 200:
            # new thread to add the page to the LRU cache
                t = threading.Thread(target=self.add_to_cache, args=(page_name, response))
                t.start()
                return response.content.decode('utf-8')
            else:
                return response
    
    def add_to_cache(self, page, response):
        filename = self.cached_folder + '/' + page
        with gzip.open(filename, 'wb') as wfile:
            wfile.write(response)
        
        fsize = os.path.getsize(filename)
        self.current_size += fsize

    def get_file(self, filepath):
        with open(self.cached_folder + "/" + filepath, 'r') as f:
            contents = gzip.decompress(f)
        return contents.decode('utf-8')

    def receive_client_rq(self):
        client_request = self.sock.recv(2048)

        request_path = client_request.split('/')[-1]

        print("the request from the client", client_request, "path, ", request_path)

        if request_path == "beacon":
            return "beacon"
        
        return request_path

    def send_html_response(self, client_rq):
        if client_rq == "beacon":
            response = "HTTP/1.1 204 No Content"
        else:
            response = self.get_html(client_rq)

        self.sock.send(response)

def main():

    httpserver = HttpServer()
    print('HTTP SERVER READY')


    while True:
        client_rq = httpserver.receive_client_rq()
        httpserver.send_html_response(client_rq)
            
main()
    
    
